package example

import (
	"fmt"

	"go.starlark.net/starlark"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/tilt-dev/tilt-starlark-codegen/test/example"
	"github.com/tilt-dev/tilt/internal/tiltfile/starkit"
	"github.com/tilt-dev/tilt/internal/tiltfile/value"
)

// AUTOGENERATED by github.com/tilt-dev/tilt-starlark-codegen
// DO NOT EDIT MANUALLY

func (p Plugin) registerSymbols(env *starkit.Environment) error {
	var err error

	err = env.AddBuiltin("example.config_map", p.configMap)
	if err != nil {
		return err
	}
	err = env.AddBuiltin("example.file_watch", p.fileWatch)
	if err != nil {
		return err
	}
	err = env.AddBuiltin("example.ignore_def", p.ignoreDef)
	if err != nil {
		return err
	}
	return nil
}
func (p Plugin) configMap(t *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	var err error
	obj := &example.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{},
	}
	var data value.StringStringMap
	var labels value.StringStringMap
	var annotations value.StringStringMap
	err = starkit.UnpackArgs(t, fn.Name(), args, kwargs,
		"name", &obj.ObjectMeta.Name,
		"labels?", &labels,
		"annotations?", &annotations,
		"data?", &data,
	)
	if err != nil {
		return nil, err
	}

	obj.Data = data
	obj.ObjectMeta.Labels = labels
	obj.ObjectMeta.Annotations = annotations
	return p.register(t, obj)
}

func (p Plugin) fileWatch(t *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	var err error
	obj := &example.FileWatch{
		ObjectMeta: metav1.ObjectMeta{},
		Spec:       example.FileWatchSpec{},
	}
	var watchedPaths value.LocalPathList = value.NewLocalPathListUnpacker(t)
	var ignores IgnoreDefList = IgnoreDefList{t: t}
	var labels value.StringStringMap
	var annotations value.StringStringMap
	err = starkit.UnpackArgs(t, fn.Name(), args, kwargs,
		"name", &obj.ObjectMeta.Name,
		"labels?", &labels,
		"annotations?", &annotations,
		"watched_paths?", &watchedPaths,
		"ignores?", &ignores,
	)
	if err != nil {
		return nil, err
	}

	obj.Spec.WatchedPaths = watchedPaths.Value
	obj.Spec.Ignores = ignores.Value
	obj.ObjectMeta.Labels = labels
	obj.ObjectMeta.Annotations = annotations
	return p.register(t, obj)
}

type IgnoreDef struct {
	*starlark.Dict
	Value      example.IgnoreDef
	isUnpacked bool
	t          *starlark.Thread // instantiation thread for computing abspath
}

func (p Plugin) ignoreDef(t *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {
	var basePath starlark.Value
	var patterns starlark.Value
	err := starkit.UnpackArgs(t, fn.Name(), args, kwargs,
		"base_path?", &basePath,
		"patterns?", &patterns,
	)
	if err != nil {
		return nil, err
	}

	dict := starlark.NewDict(2)

	if basePath != nil {
		err := dict.SetKey(starlark.String("base_path"), basePath)
		if err != nil {
			return nil, err
		}
	}
	if patterns != nil {
		err := dict.SetKey(starlark.String("patterns"), patterns)
		if err != nil {
			return nil, err
		}
	}
	var obj *IgnoreDef = &IgnoreDef{t: t}
	err = obj.Unpack(dict)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (o *IgnoreDef) Unpack(v starlark.Value) error {
	obj := example.IgnoreDef{}

	starlarkObj, ok := v.(*IgnoreDef)
	if ok {
		*o = *starlarkObj
		return nil
	}

	mapObj, ok := v.(*starlark.Dict)
	if !ok {
		return fmt.Errorf("expected dict, actual: %v", v.Type())
	}

	for _, item := range mapObj.Items() {
		keyV, val := item[0], item[1]
		key, ok := starlark.AsString(keyV)
		if !ok {
			return fmt.Errorf("key must be string. Got: %s", keyV.Type())
		}

		if key == "base_path" {
			v := value.NewLocalPathUnpacker(o.t)
			err := v.Unpack(val)
			if err != nil {
				return fmt.Errorf("unpacking %s: %v", key, err)
			}
			obj.BasePath = v.Value
			continue
		}
		if key == "patterns" {
			var v value.StringList
			err := v.Unpack(val)
			if err != nil {
				return fmt.Errorf("unpacking %s: %v", key, err)
			}
			obj.Patterns = v
			continue
		}
		return fmt.Errorf("Unexpected attribute name: %s", key)
	}

	mapObj.Freeze()
	o.Dict = mapObj
	o.Value = obj
	o.isUnpacked = true

	return nil
}

type IgnoreDefList struct {
	*starlark.List
	Value []example.IgnoreDef
	t     *starlark.Thread
}

func (o *IgnoreDefList) Unpack(v starlark.Value) error {
	items := []example.IgnoreDef{}

	listObj, ok := v.(*starlark.List)
	if !ok {
		return fmt.Errorf("expected list, actual: %v", v.Type())
	}

	for i := 0; i < listObj.Len(); i++ {
		v := listObj.Index(i)

		item := IgnoreDef{t: o.t}
		err := item.Unpack(v)
		if err != nil {
			return fmt.Errorf("at index %d: %v", i, err)
		}
		items = append(items, example.IgnoreDef(item.Value))
	}

	listObj.Freeze()
	o.List = listObj
	o.Value = items

	return nil
}
