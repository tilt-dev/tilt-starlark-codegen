package codegen

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"

	"github.com/iancoleman/strcase"
	"k8s.io/gengo/parser"
	"k8s.io/gengo/types"
)

// Find all top-level types with the tilt:starlark-gen=true tag.
func LoadStarlarkGenTypes(pkg string) (*types.Package, []*types.Type, error) {
	b := parser.New()
	err := b.AddDir(pkg)
	if err != nil {
		return nil, nil, err
	}
	universe, err := b.FindTypes()
	if err != nil {
		return nil, nil, err
	}

	pkgSpec := universe.Package(pkg)
	results := []*types.Type{}
	for _, t := range pkgSpec.Types {
		ok, err := types.ExtractSingleBoolCommentTag("+", "tilt:starlark-gen", false, t.CommentLines)
		if err != nil {
			return nil, nil, fmt.Errorf("parsing tags in %s: %v", t, err)
		}
		if ok {
			results = append(results, t)
		}
	}
	sort.Slice(results, func(i, j int) bool {
		return results[i].Name.Name < results[j].Name.Name
	})

	return pkgSpec, results, nil
}

func getSpecMemberType(t *types.Type) *types.Type {
	for _, member := range t.Members {
		if member.Name == "Spec" {
			return member.Type
		}
	}
	return nil
}

// Opens the output file and write the package header.
func OpenOutputFile(outDir string) (io.Writer, error) {
	out := os.Stdout
	pkgName := "v1alpha1"
	if outDir != "-" {
		pkgName = filepath.Base(outDir)
		outPath := filepath.Join(outDir, "types.go")

		var err error
		out, err = os.OpenFile(outPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0555)
		if err != nil {
			return nil, err
		}
	}

	_, err := fmt.Fprintf(out, `package %s

import (
	"go.starlark.net/starlark"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/tilt-dev/tilt/internal/tiltfile/starkit"
	"github.com/tilt-dev/tilt/internal/tiltfile/value"
	"github.com/tilt-dev/tilt/pkg/apis/core/v1alpha1"
)

// AUTOGENERATED by tilt-starlark-codegen. Do not edit manually.
`, pkgName)
	if err != nil {
		_ = out.Close()
		return nil, err
	}
	return out, nil
}

// closes the output file and writes any trailing comments
func CloseOutputFile(w io.Writer) error {
	closable, ok := w.(io.Closer)
	if !ok {
		return nil
	}

	return closable.Close()
}

// Given a gengo Type, create a starlark function that reads that type.
func WriteStarlarkFunction(t *types.Type, pkg *types.Package, w io.Writer) error {
	tName := t.Name.Name
	fnName := strcase.ToLowerCamel(tName)
	spec := getSpecMemberType(t)
	if spec == nil {
		return fmt.Errorf("type has no spec: %s", tName)
	}

	objTypeName := fmt.Sprintf("%s.%s", pkg.Name, tName)

	// Print the function signature.
	_, err := fmt.Fprintf(w, `
func (p Plugin) %s(t *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {`,
		fnName)
	if err != nil {
		return err
	}

	// Print the object initializer.
	_, err = fmt.Fprintf(w, `
	obj := &%s{
		ObjectMeta: metav1.ObjectMeta{},
		Spec: %sSpec{},
	}`, objTypeName, objTypeName)
	if err != nil {
		return err
	}

	// Print the object unpacker.
	_, err = fmt.Fprintf(w, `
  var labels value.StringStringMap
	var annotations value.StringStringMap
	err := starkit.UnpackArgs(t, fn.Name(), args, kwargs,
		"name", &obj.ObjectMeta.Name,
		"labels?", &labels,
		"annotations?", &annotations,`)
	if err != nil {
		return err
	}

	// Print unpackers of individual members.
	for _, member := range spec.Members {
		_, err = fmt.Fprintf(w, `
    "%s", &obj.Spec.%s,`, strcase.ToSnake(member.Name), member.Name)
		if err != nil {
			return err
		}
	}

	// Print the trailer
	_, err = fmt.Fprintf(w, `
  )

  if err != nil {
    return nil, err
  }
	return p.register(t, obj)
}
`)
	if err != nil {
		return err
	}
	return nil
}
