package codegen

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"

	"github.com/iancoleman/strcase"
	"k8s.io/gengo/parser"
	"k8s.io/gengo/types"
)

// Find all top-level types with the tilt:starlark-gen=true tag.
func LoadStarlarkGenTypes(pkg string) (*types.Package, []*types.Type, error) {
	b := parser.New()
	err := b.AddDir(pkg)
	if err != nil {
		return nil, nil, err
	}
	universe, err := b.FindTypes()
	if err != nil {
		return nil, nil, err
	}

	pkgSpec := universe.Package(pkg)
	results := []*types.Type{}
	for _, t := range pkgSpec.Types {
		ok, err := types.ExtractSingleBoolCommentTag("+", "tilt:starlark-gen", false, t.CommentLines)
		if err != nil {
			return nil, nil, fmt.Errorf("parsing tags in %s: %v", t, err)
		}
		if ok {
			results = append(results, t)
		}
	}
	sort.Slice(results, func(i, j int) bool {
		return results[i].Name.Name < results[j].Name.Name
	})

	return pkgSpec, results, nil
}

func getSpecMemberType(t *types.Type) *types.Type {
	for _, member := range t.Members {
		if member.Name == "Spec" {
			return member.Type
		}
	}
	return nil
}

// Opens the output file.
func OpenOutputFile(outDir string) (io.Writer, error) {
	out := os.Stdout
	if outDir != "-" {
		outPath := filepath.Join(outDir, "types.go")

		var err error
		out, err = os.OpenFile(outPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0555)
		if err != nil {
			return nil, err
		}
	}
	return out, nil
}

// Writes the package header.
func WritePreamble(pkg *types.Package, w io.Writer) error {

	_, err := fmt.Fprintf(w, `package %s

import (
	"go.starlark.net/starlark"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	"github.com/tilt-dev/tilt/internal/tiltfile/starkit"
	"github.com/tilt-dev/tilt/internal/tiltfile/value"
	"github.com/tilt-dev/tilt/pkg/apis/core/v1alpha1"
)

// AUTOGENERATED by github.com/tilt-dev/tilt-starlark-codegen
// DO NOT EDIT MANUALLY
`, pkg.Name)
	if err != nil {
		return err
	}
	return nil
}

func unpackMemberVarName(m types.Member) string {
	if m.Name == "Args" {
		return "specArgs"
	}
	if m.Name == "Labels" {
		return "specLabels"
	}
	if m.Name == "Annotations" {
		return "specAnnotations"
	}
	return strcase.ToLowerCamel(m.Name)
}

// Helper function to determine how to unpack fields.
//
// A ("", obj.Spec.Name) if this does not need a special unpack var.
// A (Type, Name) pair if this does need a special unpack var.
// error if we don't know how to unpack this field.
func unpackMemberVar(m types.Member) (string, string, error) {
	t := m.Type
	if t.Kind == types.Builtin {
		return "", fmt.Sprintf("obj.Spec.%s", m.Name), nil
	}

	if t.Kind == types.Slice {
		if t.Elem.Kind == types.Builtin && t.Elem.Name.Name == "string" {
			return "value.StringList", unpackMemberVarName(m), nil
		}
	}
	return "", "", fmt.Errorf("Cannot unpack member %s", m.Name)
}

// Given a gengo Type, create a starlark function that reads that type.
func WriteStarlarkFunction(t *types.Type, pkg *types.Package, w io.Writer) error {
	tName := t.Name.Name
	fnName := strcase.ToLowerCamel(tName)
	spec := getSpecMemberType(t)
	if spec == nil {
		return fmt.Errorf("type has no spec: %s", tName)
	}

	objTypeName := fmt.Sprintf("%s.%s", pkg.Name, tName)

	// Print the function signature.
	_, err := fmt.Fprintf(w, `
func (p Plugin) %s(t *starlark.Thread, fn *starlark.Builtin, args starlark.Tuple, kwargs []starlark.Tuple) (starlark.Value, error) {`,
		fnName)
	if err != nil {
		return err
	}

	// Print the object initializer.
	_, err = fmt.Fprintf(w, `
	obj := &%s{
		ObjectMeta: metav1.ObjectMeta{},
		Spec: %sSpec{},
	}`, objTypeName, objTypeName)
	if err != nil {
		return err
	}

	// Print any special unpack vars.
	for _, member := range spec.Members {
		varT, varN, err := unpackMemberVar(member)
		if err != nil {
			return fmt.Errorf("generating type %s: %v", tName, err)
		}

		if varT == "" {
			continue
		}

		_, err = fmt.Fprintf(w, `
  var %s %s`, varN, varT)
		if err != nil {
			return err
		}
	}

	// Print the object unpacker.
	_, err = fmt.Fprintf(w, `
  var labels value.StringStringMap
	var annotations value.StringStringMap
	err := starkit.UnpackArgs(t, fn.Name(), args, kwargs,
		"name", &obj.ObjectMeta.Name,
		"labels?", &labels,
		"annotations?", &annotations,`)
	if err != nil {
		return err
	}

	// Print unpackers of individual members.
	for _, member := range spec.Members {
		_, varN, _ := unpackMemberVar(member)
		_, err = fmt.Fprintf(w, `
    "%s?", &%s,`, strcase.ToSnake(member.Name), varN)
		if err != nil {
			return err
		}
	}

	// Print the end of arg parsing.
	_, err = fmt.Fprintf(w, `
  )
  if err != nil {
    return nil, err
  }
`)
	if err != nil {
		return err
	}

	// Copy unpackers into the object.
	for _, member := range spec.Members {
		varT, varN, _ := unpackMemberVar(member)
		if varT == "" {
			continue
		}
		_, err = fmt.Fprintf(w, `
    obj.Spec.%s = %s`, member.Name, varN)
		if err != nil {
			return err
		}
	}

	// Register the type.
	_, err = fmt.Fprintf(w, `
	return p.register(t, obj)
}
`)
	if err != nil {
		return err
	}
	return nil
}
